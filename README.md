# microservices

The rise of microservices has been a remarkable advancement in application development and deployment. With microservices, an application is developed, or refactored, into separate services that “speak” to one another in a well-defined way –via APIs, for instance. Each microservice is self-contained, each maintains its own data store (which has significant implications), and each can be updated independently of others.

Moving to a microservices-based approach makes app development faster and easier to manage, requiring fewer people to implement more new features. Changes can be made and deployed faster and easier. An application designed as a collection of microservices is easier to run on multiple servers with load balancing, making it easy to handle demand spikes and steady increases in demand over time, while reducing downtime caused by hardware or software problems.

Microservices are a critical part of a number of significant advancements that are changing the nature of how we work. Agile software development techniques, moving applications to the cloud, DevOps culture, continuous integration and continuous deployment (CI/CD), and the use of containers are all being used alongside microservices to revolutionize application development and delivery.

**Using an API Gateway** – An API Gateway is the single point of entry for entire microservices-based application, presenting the API for each microservice.

**Inter-process Communication in a Microservices Architecture** - Once you break a monolithic application into separate pieces – microservices – the pieces need to speak to each other. And it turns out that you have many options for inter-process communication, including representational state transfer (REST).

**Service Discovery in a Microservices Architecture** – When services are running in a dynamic environment, finding them when you need them is not a trivial issue.

**Event-Driven Data Management for Microservices** – Instead of sharing a unified application-wide data store (or two) across a monolithic application, each microservice maintains its own unique data representation and storage. This gives you great flexibility, but can also cause complexity.

**Choosing a Microservices Deployment Strategy** – In a DevOps world, how you do things is just as important as what you set out to do in the first place.

**Refactoring a Monolith into Microservices** – In a perfect world, we would always get the time and money to convert core software into the latest and greatest technologies, tools, and approaches, with no real deadlines. But you may well find yourself converting a monolith into microservices, one… small… piece… at… a… time.

Do you want build the Enterprise Software Systems?
The following is a list of common characteristics that need to be available in a good enterprise software system:  
    • Scalability  
    • Availability  
    • Latency   
    • Robustness  
    • Security  
    • Modularity  
    • Reusability  
    • Replaceability  
    • Observability  
    • Adaptability  

**Scalability**: In the past, the growth of an enterprise took a considerable amount of time, and the enterprise teams had enough lead time to plan on scaling the applications. But in today’s world, enterprises can launch their products and services to larger audiences through the Internet, and the growth of the customer base can be instantaneous. Sometimes, you would receive ten times more traffic than what you initially estimated, and your enterprise system should be capable of scaling to these demands instantly. Utilize technologies provided by infrastructure providers to automatically scale the components based on certain metrics such as CPU usage, latency, or number of users. There are two types of scalability: _**Horizontal scalability**_ and _**Vertical scalability**_

Horizontal scalability: Adding more instances of a microservice to distribute the workload across multiple servers. This is particularly effective for handling increased traffic or high demand.    
Vertical scalability: Increasing the resources (e.g., CPU, memory) of a single microservice instance. 

**Availability**: In the world of business, time is money. If you are offering products and services through omni-channels such as mobile, web, and telephone, your system needs to be available and accessible to the users at any given time.But in reality, the cost to support 100% availability is much higher when compared to the cost that involves providing four nines (99.99%) of availability.    
_There are different systems and applications that require a certain level of minimum deployment to support high availability. In a typical stateless web application such as Tomcat or API gateway, having a two-instance deployment with both instances in an active mode would provide the high availability. A load balancer will be used to distribute the traffic coming into the web server in a round-robin fashion. When planning the capacity of the servers, it needs to be planned so that the overall capacity of both the nodes can provide two times the expected (or peak) capacity of the platform. When we do that, in the case of a single instance failure, the system will still function at 100% capacity without disrupting the availability. In a stateful application with data replication, you may need more than two instances to provide the minimum high availability._    

**Latency**: The Internet has become so fast that consumers expect things to be available at their fingertips in a blink of an eye. But as enterprise systems designers, we need to deal with complexities such as varying systems, varying data types and formats, and even varying deployments (geographically).     
As an example, _if a customer needs to check a particular item in an e-commerce website, that single web page provides details about product features, price, availability, related products, and even the estimated shipping cost. These different types of information come from different core systems that may be running in different data centers across the world. But the end user does not care about any of these complexities, and they expect all the details to be available instantly. Due to this reason, it is important to consider the overall latency of the platform when designing enterprise systems. You need to make sure that there are a minimum number of network interactions and data is stored in canonical format within the platform so that data transformation costs are minimal. But in some cases, we might not be able to avoid all these complexities since the application may require data from legacy systems that are hard to change._ From this point several technologies that can be used to improve the performance and reduce the latency such as caching that can be implemented with several approaches such as in-memory and persistence modes.

**Robustness**: Enterprise systems are built on top of computer networks that are destined to fail from time to time. It is really hard to design networks that do not fail. The term “robustness” does not mean that our system should be without any failure. But it discusses how resilient our system is to these failures. As an example, _a robust system would not experience cascading failures from one system to other systems. It would avoid such cascading of failures by applying techniques such as circuit breaker, which would eventually isolate the failed application from the rest of the system for a certain amount of time. After that duration, it checks the health of the failed application and reconnects that to the system._

**Security**: Enterprise software systems generate a large amount of data that needs to be properly stored, processed, and distributed to the relevant stakeholders. Every time we touch enterprise data, one thing we need to make sure of is the security of data. Data needs to be secured when stored (data at rest) in data stores using techniques such as encryption so that only the intended clients can access the stored data. This functionality is provided by the applications that generate the data and the databases that store the data in storage systems such as disks.    
Another aspect of enterprise security is securing data in motion. That means when the data is accessed through a network using a mobile or web application, the communication channel needs to be secured using mechanisms such as transport layer security so that an attacker who hacks into the network cannot access the data in transit. _We use technologies such as Secure Sockets Layer (SSL) and Transport Layer Security (TLS) for this purpose_.    
The more prominent or the customer-facing aspect of enterprise security is the _application-level security with authentication and authorization_. If a user needs to access any information from the enterprise software system, that user needs to have the required permissions before accessing it. Authentication verifies the user and identifies that user as a valid user in the system. Authorization makes sure that the identified user has the authority to execute certain actions on enterprise data. We will be discussing this topic in detail in the upcoming chapters dedicated to enterprise security patterns.

**Modularity**: One of the main challenges people have to deal with when designing enterprise software systems is the complexity of the system that increases with time. In early enterprise software systems, large monolithic applications were deployed in the enterprise ecosystem, and the integration of these systems was done in a point-to-point manner with custom code written specifically for each integration. _Enterprise architects then realized the challenges of maintaining such deployments and came up with the idea of Service-Oriented Architecture where each functionality required by the system is developed as separate services and integrations across services and other systems happened through standard interfaces such as REST, SOAP, or JMS to name a few.This approach helped the enterprise architects to design services with clear goals and made it easy to develop new features specifically for the required services without overhauling the entire application. This concept was then evolved into a more independent services development and deployment model with the introduction of microservice architecture and containers. It improved the overall system availability and agility by allowing individual services to maintain their own life cycle so that each service could be managed by entirely different teams with expertise on specific domains._    
_Having modular architecture such as SOA or microservice architecture helped the enterprise software systems to become more resilient to failures since one component failure could not impact the overall system behavior. In addition to that, it also allowed these individual modules (services) to innovate independently and bring new experiences to the customers without worrying about the readiness of the entire platform, which would otherwise delay the innovation. It also helped isolate errors and made troubleshooting easier by identifying errors related to specific components and allowed developers to quickly work on a resolution rather than going through the entire system._

**Reusability**: _A common approach to build such a shared platform is to use a centralized application portal where each team can publish their services into the portal and any other team can reuse the services without duplicating it.With a reusable development model, teams can collaborate with others without going down their own siloed universes. It helps organizations to spend valuable engineering resources on critical tasks rather than using them for duplicating existing functionality. It also helps the enterprise to develop new services at a faster rate and reduce the time to market. The service developers would also get valuable feedback from other teams, which would help them to improve the service quality and the features it offers._

**Replaceability**: Enterprise software systems are going through continuous improvements, and replacing existing functionality with new products and vendors has become a more frequent task recently. There can be many reasons such as stability issues, performance issues, feature gaps, product support quality issues, support availability issues, and most commonly pricing challenges. Because of these reasons, we cannot guarantee that any component in the enterprise software system would last forever. _The best approach to implement such an architecture is to use components that support standards based interfaces for integrations.As an example, if we are to select an API management platform for an enterprise, we need to make sure that the product we select supports standard API definition formats such as Swagger or OpenAPI specification so that in case we need to replace this product with another vendor, we can reuse the same API definitions to migrate APIs into the new vendor._

**Observability**: Large enterprise software systems with hundreds of applications running in parallel with complex integrations within these applications can make it harder to troubleshoot if no proper observability is implemented. Hence, it is a best practice to implement observability from the initial stages of the system design and implementation so that the system's observability, which is a property of the overall system, keeps on improving with time._ Monitoring is a function within the enterprise that uses various observability outputs to keep an eye on the stability of the system. It helps developers to keep the system in a good state and recover from failures as soon as possible._

**Adaptability**: Executive leaders always look to improve the performance of the enterprise due to the steep competition coming from the alternate enterprises. This sheer competition impacts all the different functions within the enterprise, and hence, enterprise software systems need to adapt to the continuous change requests coming from the executive leadership. As an example, as part of a global expansion within the enterprise, executives ask enterprise architects to bring in more and more systems to manage global operations._ In such a scenario, the enterprise systems should have the capability to integrate with those systems without impacting the existing applications. It also means that the system is agile and flexible to adopt the changes fast and move forward._
